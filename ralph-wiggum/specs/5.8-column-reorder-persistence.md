# Spec: Phase 5.8 - Column Reorder Persistence

> **Goal:** Persist column reordering to the database when columns are dragged.
> **Context:** Column drag-and-drop works visually but changes are lost on page refresh.
> **Priority:** P1 - High (data loss on refresh)

## Background

The Kanban board supports dragging columns to reorder them. Currently:
- Visual reordering works via dnd-kit
- Zustand store is updated
- **No API call is made** to persist the new order
- Page refresh restores original column order from database

The board's column configuration is stored in the `boards` table:
```sql
CREATE TABLE boards (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  filters TEXT,  -- JSON: { types: [], parentId: string }
  columnConfig TEXT,  -- JSON: [{ id, title, statusMappings }]
  ...
);
```

## Root Cause

**File:** `src/features/kanban/hooks/use-column-mutations.ts`

Current mutations:
- `useAddColumnMutation` - Adds a new column
- `useUpdateColumnMutation` - Renames/updates a column
- `useRemoveColumnMutation` - Deletes a column
- **Missing:** `useReorderColumnsMutation`

**File:** `src/features/kanban/components/kanban-board.tsx`

In `onDragEnd`, when a column is dropped:
```typescript
if (isActiveAColumn) {
  // Updates Zustand store only
  setColumns(arrayMove(columns, activeIndex, overIndex));
  // NO API CALL TO PERSIST
}
```

## 1. Create Reorder Mutation
**File:** `src/features/kanban/hooks/use-column-mutations.ts`

**Add:**
```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { updateBoard } from '@/features/kanban/api';
import { queryKeys } from '@/lib/query-keys';
import type { Column } from '../types';

/**
 * Mutation to persist column reordering to the database.
 * Called when columns are dragged to new positions.
 */
export function useReorderColumnsMutation(boardId: string) {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (columns: Column[]) => {
      // Convert Column[] to ColumnConfig[] format expected by API
      const columnConfig = columns.map((col) => ({
        id: col.id,
        title: col.title,
        statusMappings: [col.id],  // Maintain existing mapping pattern
      }));
      
      return updateBoard(boardId, { columnConfig });
    },
    onSuccess: () => {
      // Invalidate board query to refetch with new order
      queryClient.invalidateQueries({ 
        queryKey: queryKeys.kanban(boardId) 
      });
    },
    onError: (error) => {
      console.error('[Column Reorder] Failed to persist:', error);
      // Optionally: Show toast notification
      // Optionally: Rollback Zustand store to previous order
    },
  });
}
```

## 2. Export Mutation
**File:** `src/features/kanban/hooks/use-column-mutations.ts`

Ensure the new hook is exported:
```typescript
export { 
  useAddColumnMutation,
  useUpdateColumnMutation,
  useRemoveColumnMutation,
  useReorderColumnsMutation,  // Add this
};
```

## 3. Integrate into onDragEnd
**File:** `src/features/kanban/components/kanban-board.tsx`

**Current Code:**
```typescript
function onDragEnd(event: DragEndEvent) {
  // ... existing logic ...
  
  if (isActiveAColumn) {
    const activeIndex = columns.findIndex((col) => col.id === activeId);
    const overIndex = columns.findIndex((col) => col.id === overId);
    setColumns(arrayMove(columns, activeIndex, overIndex));  // Zustand only
    return;
  }
  // ... task handling ...
}
```

**Updated Code:**
```typescript
import { useReorderColumnsMutation } from '../hooks/use-column-mutations';

// Inside KanbanBoard component:
const reorderColumnsMutation = useReorderColumnsMutation(boardId);

function onDragEnd(event: DragEndEvent) {
  // ... existing logic ...
  
  if (isActiveAColumn) {
    const activeIndex = columns.findIndex((col) => col.id === activeId);
    const overIndex = columns.findIndex((col) => col.id === overId);
    
    // Optimistic UI update
    const reorderedColumns = arrayMove(columns, activeIndex, overIndex);
    setColumns(reorderedColumns);
    
    // Persist to database
    reorderColumnsMutation.mutate(reorderedColumns);
    return;
  }
  // ... task handling ...
}
```

## 4. Verify Backend Endpoint
**File:** `src/app/api/boards/[id]/route.ts`

**Check:** Ensure PATCH/PUT accepts `columnConfig`:
```typescript
// Expected request body
interface UpdateBoardRequest {
  title?: string;
  filters?: BoardFilters;
  columnConfig?: ColumnConfig[];  // Must accept this
}

export async function PATCH(request: Request, { params }: RouteParams) {
  const body = await request.json();
  // Validate with Zod
  // Update board in database
  // Return updated board
}
```

**File:** `src/services/board-service.ts`

**Check:** Service layer handles `columnConfig` updates:
```typescript
async updateBoard(id: string, data: Partial<Board>): Promise<Board> {
  // Should accept columnConfig in data
  // Should serialize columnConfig to JSON for SQLite
}
```

## 5. API Layer Function
**File:** `src/features/kanban/api.ts`

**Check:** Ensure `updateBoard` function exists:
```typescript
export async function updateBoard(
  id: string, 
  data: { title?: string; filters?: BoardFilters; columnConfig?: ColumnConfig[] }
): Promise<Board> {
  const response = await fetch(`/api/boards/${id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  
  if (!response.ok) {
    throw new ApiError('Failed to update board', 'UPDATE_FAILED', response.status);
  }
  
  const result = await response.json();
  return result.data;
}
```

## 6. Optimistic Update with Rollback (Optional Enhancement)
**File:** `src/features/kanban/hooks/use-column-mutations.ts`

For better UX, implement rollback on error:
```typescript
export function useReorderColumnsMutation(boardId: string) {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (columns: Column[]) => {
      // ... same as above
    },
    onMutate: async (newColumns) => {
      // Cancel any outgoing refetches
      await queryClient.cancelQueries({ queryKey: queryKeys.board(boardId) });
      
      // Snapshot previous value for rollback
      const previousBoard = queryClient.getQueryData(queryKeys.board(boardId));
      
      return { previousBoard };
    },
    onError: (error, variables, context) => {
      // Rollback to previous state
      if (context?.previousBoard) {
        queryClient.setQueryData(queryKeys.board(boardId), context.previousBoard);
      }
      // Show error toast
    },
    onSettled: () => {
      // Refetch to ensure consistency
      queryClient.invalidateQueries({ queryKey: queryKeys.kanban(boardId) });
    },
  });
}
```

## Verification Checklist
- [ ] Drag column A to position after column B
- [ ] Console shows no errors
- [ ] Refresh page
- [ ] Column A is still after column B (persisted)
- [ ] Repeat for moving column to first position
- [ ] Repeat for moving column to last position
- [ ] Test with 4+ columns

## Files to Modify
| File | Action |
|------|--------|
| `src/features/kanban/hooks/use-column-mutations.ts` | Add `useReorderColumnsMutation` |
| `src/features/kanban/components/kanban-board.tsx` | Call mutation in `onDragEnd` |
| `src/features/kanban/api.ts` | Verify `updateBoard` accepts `columnConfig` |
| `src/app/api/boards/[id]/route.ts` | Verify PATCH handles `columnConfig` |
| `src/services/board-service.ts` | Verify service serializes `columnConfig` |

## Related Specs
- `5.3-drag-persistence.md` - Task drag persistence (similar pattern)
